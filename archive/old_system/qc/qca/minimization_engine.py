"""
QCA Boolean Minimization Engine - Phase QCA-3
Integrates with external QCA tools for Boolean minimization and configurational analysis
"""
import json
import logging
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import csv

from .qca_schemas import QCAConfiguration, TruthTable, QCAResults
from .truth_table_builder import TruthTableBuilder

logger = logging.getLogger(__name__)

class MinimizationEngine:
    """Engine for Boolean minimization and configurational analysis"""
    
    def __init__(self, config: QCAConfiguration):
        self.config = config
        self.truth_tables: List[TruthTable] = []
    
    def load_truth_tables(self, truth_tables: List[TruthTable] = None) -> None:
        """Load truth tables from file or parameter"""
        if truth_tables:
            self.truth_tables = truth_tables
            logger.info(f"Loaded {len(truth_tables)} truth tables from parameter")
            return
        
        # Load from files
        output_path = Path(self.config.output_dir)
        truth_table_files = list(output_path.glob("truth_table_*.json"))
        
        for file_path in truth_table_files:
            with open(file_path, 'r', encoding='utf-8') as f:
                truth_table_data = json.load(f)
                truth_table = TruthTable(**truth_table_data)
                self.truth_tables.append(truth_table)
        
        logger.info(f"Loaded {len(self.truth_tables)} truth tables from files")
    
    def generate_r_qca_script(self, truth_table: TruthTable) -> str:
        """Generate R script for QCA package analysis"""
        outcome_id = truth_table.outcome
        condition_names = truth_table.conditions
        
        # Create R script template
        r_script = f'''
# QCA Analysis Script for {outcome_id}
# Generated by qualitative_coding pipeline

library(QCA)
library(dplyr)

# Load truth table data
data <- read.csv("truth_table_{outcome_id}.csv", stringsAsFactors = FALSE)

# Define conditions and outcome
conditions <- c({", ".join(f'"{cond}"' for cond in condition_names)})
outcome <- "{outcome_id}"

# Create QCA dataset
qca_data <- data[, c(conditions, outcome)]

# Convert to appropriate data types
for(col in conditions) {{
    qca_data[[col]] <- as.numeric(qca_data[[col]])
}}
qca_data[[outcome]] <- as.numeric(qca_data[[outcome]])

# Print data summary
cat("\\n=== Data Summary ===\\n")
print(summary(qca_data))

# Create truth table
truth_table <- truthTable(qca_data, outcome = outcome, conditions = conditions,
                         complete = TRUE, show.cases = TRUE)

cat("\\n=== Truth Table ===\\n")
print(truth_table)

# Perform QCA minimization - Conservative solution
conservative <- minimize(truth_table, details = TRUE)
cat("\\n=== Conservative Solution ===\\n")
print(conservative)

# Perform QCA minimization - Parsimonious solution
parsimonious <- minimize(truth_table, include = "?", details = TRUE)
cat("\\n=== Parsimonious Solution ===\\n")
print(parsimonious)

# Perform QCA minimization - Intermediate solution (if possible)
tryCatch({{
    intermediate <- minimize(truth_table, include = "?", dir.exp = "1,1,1,1,1", details = TRUE)
    cat("\\n=== Intermediate Solution ===\\n")
    print(intermediate)
}}, error = function(e) {{
    cat("\\nIntermediate solution not available:", e$message, "\\n")
}})

# Calculate fit measures
fit_measures <- pof(conservative$solution, qca_data, outcome = outcome)
cat("\\n=== Fit Measures ===\\n")
print(fit_measures)

# Save results
write.csv(truth_table$tt, "qca_truth_table_{outcome_id}.csv", row.names = FALSE)

# Create solution summary
solution_summary <- list(
    outcome = outcome,
    conditions = conditions,
    conservative_solution = conservative$solution,
    parsimonious_solution = parsimonious$solution,
    fit_measures = fit_measures,
    n_cases = nrow(qca_data),
    n_configurations = nrow(truth_table$tt)
)

# Save as JSON for further processing
library(jsonlite)
write_json(solution_summary, "qca_solution_{outcome_id}.json", pretty = TRUE)

cat("\\n=== Analysis Complete ===\\n")
cat("Results saved to: qca_solution_{outcome_id}.json\\n")
'''
        
        return r_script
    
    def generate_python_qca_script(self, truth_table: TruthTable) -> str:
        """Generate Python script using pyQCA or custom minimization"""
        outcome_id = truth_table.outcome
        condition_names = truth_table.conditions
        
        python_script = f'''
"""
Python QCA Analysis Script for {outcome_id}
Generated by qualitative_coding pipeline
"""

import pandas as pd
import json
from typing import Dict, List, Set
from itertools import product

def load_truth_table():
    """Load truth table data"""
    df = pd.read_csv("truth_table_{outcome_id}.csv")
    return df

def quine_mccluskey_minimize(truth_table_df):
    """
    Simple Quine-McCluskey minimization implementation
    For more advanced minimization, integrate with pyQCA or R QCA package
    """
    conditions = {condition_names}
    outcome = "{outcome_id}"
    
    # Extract positive configurations (outcome = 1)
    positive_configs = []
    for _, row in truth_table_df.iterrows():
        if row[outcome] >= 0.5:  # Treat as positive outcome
            config = tuple(int(row[cond]) for cond in conditions)
            positive_configs.append(config)
    
    print(f"Positive configurations: {{len(positive_configs)}}")
    for i, config in enumerate(positive_configs):
        config_str = " * ".join([
            f"{{cond}}{{'' if config[j] else '~'}}" 
            for j, cond in enumerate(conditions)
        ])
        print(f"  Config {{i+1}}: {{config_str}}")
    
    # Simple minimization: find common patterns
    if len(positive_configs) <= 1:
        return positive_configs
    
    # This is a simplified version - real QCA would use proper minimization
    return positive_configs

def calculate_solution_coverage_consistency(truth_table_df):
    """Calculate coverage and consistency for solutions"""
    conditions = {condition_names}
    outcome = "{outcome_id}"
    
    results = {{}}
    
    # Overall statistics
    total_cases = len(truth_table_df)
    positive_cases = len(truth_table_df[truth_table_df[outcome] >= 0.5])
    
    results["total_cases"] = total_cases
    results["positive_cases"] = positive_cases
    results["solution_coverage"] = positive_cases / total_cases if total_cases > 0 else 0
    
    return results

def main():
    print("=== Python QCA Analysis for {outcome_id} ===")
    
    # Load data
    df = load_truth_table()
    print(f"Loaded {{len(df)}} configurations")
    
    # Perform minimization
    minimized = quine_mccluskey_minimize(df)
    
    # Calculate metrics
    metrics = calculate_solution_coverage_consistency(df)
    
    # Create results summary
    results = {{
        "outcome": "{outcome_id}",
        "conditions": {condition_names},
        "minimized_configurations": minimized,
        "metrics": metrics,
        "note": "This is a simplified minimization. For full QCA analysis, use R QCA package."
    }}
    
    # Save results
    with open("python_qca_solution_{outcome_id}.json", "w") as f:
        json.dump(results, f, indent=2)
    
    print("\\n=== Results Summary ===")
    print(f"Minimized to {{len(minimized)}} configurations")
    print(f"Solution coverage: {{metrics['solution_coverage']:.3f}}")
    print("\\nResults saved to: python_qca_solution_{outcome_id}.json")

if __name__ == "__main__":
    main()
'''
        
        return python_script
    
    def generate_neo4j_cypher(self, truth_table: TruthTable) -> str:
        """Generate Cypher queries for Neo4j graph analysis"""
        outcome_id = truth_table.outcome
        condition_names = truth_table.conditions
        
        cypher_script = f'''
// Neo4j Cypher Queries for QCA Analysis: {outcome_id}
// Generated by qualitative_coding pipeline

// 1. Create Configuration nodes
UNWIND $configurations AS config
MERGE (c:Configuration {{id: config.id}})
SET c += config.properties,
    c.outcome = config.{outcome_id},
    c.case_count = size(config.cases)

// 2. Create Condition nodes  
UNWIND {condition_names} AS condition_name
MERGE (cond:Condition {{name: condition_name}})

// 3. Create relationships between Configurations and Conditions
UNWIND $configurations AS config
MATCH (c:Configuration {{id: config.id}})
UNWIND {condition_names} AS cond_name
WITH c, config, cond_name, config.properties[cond_name] AS membership
MATCH (cond:Condition {{name: cond_name}})
MERGE (c)-[r:HAS_CONDITION]->(cond)
SET r.membership = membership,
    r.is_present = CASE WHEN membership >= 0.5 THEN true ELSE false END

// 4. Find necessary conditions (present in all positive outcomes)
MATCH (c:Configuration)-[r:HAS_CONDITION]->(cond:Condition)
WHERE c.{outcome_id} >= 0.5 AND r.membership >= 0.5
WITH cond, count(DISTINCT c) AS positive_with_condition
MATCH (c2:Configuration)  
WHERE c2.{outcome_id} >= 0.5
WITH cond, positive_with_condition, count(DISTINCT c2) AS total_positive
WHERE positive_with_condition = total_positive
RETURN cond.name AS necessary_condition, 
       positive_with_condition AS cases_with_condition,
       total_positive AS total_positive_cases,
       1.0 AS necessity_score

// 5. Find sufficient conditions (configurations that always lead to positive outcome)
MATCH (c:Configuration)-[r:HAS_CONDITION]->(cond:Condition)
WHERE r.membership >= 0.5
WITH c, collect(cond.name) AS active_conditions
WHERE c.{outcome_id} >= 0.5
RETURN active_conditions AS sufficient_configuration,
       c.{outcome_id} AS outcome_score,
       c.case_count AS supporting_cases
ORDER BY c.{outcome_id} DESC, c.case_count DESC

// 6. Calculate coverage and consistency for each condition
MATCH (cond:Condition)<-[r:HAS_CONDITION]-(c:Configuration)
WITH cond, 
     sum(CASE WHEN r.membership >= 0.5 AND c.{outcome_id} >= 0.5 THEN 1 ELSE 0 END) AS positive_with_cond,
     sum(CASE WHEN r.membership >= 0.5 THEN 1 ELSE 0 END) AS total_with_cond,
     sum(CASE WHEN c.{outcome_id} >= 0.5 THEN 1 ELSE 0 END) AS total_positive
RETURN cond.name AS condition,
       positive_with_cond,
       total_with_cond,
       total_positive,
       CASE WHEN total_with_cond > 0 
            THEN toFloat(positive_with_cond) / total_with_cond 
            ELSE 0.0 END AS consistency,
       CASE WHEN total_positive > 0 
            THEN toFloat(positive_with_cond) / total_positive 
            ELSE 0.0 END AS coverage
ORDER BY consistency DESC, coverage DESC

// 7. Export results for external analysis
MATCH (c:Configuration)
OPTIONAL MATCH (c)-[r:HAS_CONDITION]->(cond:Condition)
WITH c, collect({{condition: cond.name, membership: r.membership}}) AS conditions
RETURN c.id AS configuration_id,
       c.{outcome_id} AS outcome,
       c.case_count AS cases,
       conditions
'''
        
        return cypher_script
    
    def run_external_qca_analysis(self, truth_table: TruthTable) -> Dict[str, str]:
        """Run external QCA analysis tools"""
        output_path = Path(self.config.output_dir)
        output_path.mkdir(parents=True, exist_ok=True)
        
        outcome_id = truth_table.outcome
        generated_files = {}
        
        # Generate R script
        if self.config.r_qca_package:
            r_script = self.generate_r_qca_script(truth_table)
            r_file = output_path / f"qca_analysis_{{outcome_id}}.R"
            with open(r_file, 'w', encoding='utf-8') as f:
                f.write(r_script)
            generated_files['r_script'] = str(r_file)
            logger.info(f"Generated R QCA script: {{r_file}}")
        
        # Generate Python script
        if self.config.python_qca:
            python_script = self.generate_python_qca_script(truth_table)
            python_file = output_path / f"qca_analysis_{{outcome_id}}.py"
            with open(python_file, 'w', encoding='utf-8') as f:
                f.write(python_script)
            generated_files['python_script'] = str(python_file)
            logger.info(f"Generated Python QCA script: {{python_file}}")
        
        # Generate Neo4j Cypher
        if self.config.neo4j_export:
            cypher_script = self.generate_neo4j_cypher(truth_table)
            cypher_file = output_path / f"qca_analysis_{{outcome_id}}.cypher"
            with open(cypher_file, 'w', encoding='utf-8') as f:
                f.write(cypher_script)
            generated_files['cypher_script'] = str(cypher_file)
            logger.info(f"Generated Neo4j Cypher script: {{cypher_file}}")
        
        return generated_files
    
    def create_qca_data_exports(self) -> List[str]:
        """Create data exports in various formats for external QCA tools"""
        output_path = Path(self.config.output_dir)
        export_files = []
        
        for truth_table in self.truth_tables:
            outcome_id = truth_table.outcome
            
            # Create combined data export with all cases
            combined_file = output_path / f"qca_data_{{outcome_id}}.csv"
            self._create_combined_data_export(truth_table, combined_file)
            export_files.append(str(combined_file))
            
            # Create configuration-based export (aggregated by configuration)
            config_file = output_path / f"qca_configurations_{{outcome_id}}.csv"
            self._create_configuration_export(truth_table, config_file)
            export_files.append(str(config_file))
        
        return export_files
    
    def _create_combined_data_export(self, truth_table: TruthTable, output_file: Path) -> None:
        """Create combined data export with individual cases"""
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # Header
            header = truth_table.conditions + [truth_table.outcome] + ['case_id', 'configuration_id']
            writer.writerow(header)
            
            # Data rows - expand each configuration to individual cases
            for i, row in enumerate(truth_table.rows):
                config_id = f"config_{{i+1}}"
                
                for case_id in row.cases:
                    data_row = []
                    
                    # Condition values
                    for cond_id in truth_table.conditions:
                        data_row.append(row.configuration.get(cond_id, 0.0))
                    
                    # Outcome, case_id, configuration_id
                    data_row.extend([row.outcome, case_id, config_id])
                    writer.writerow(data_row)
    
    def _create_configuration_export(self, truth_table: TruthTable, output_file: Path) -> None:
        """Create configuration-based export (one row per configuration)"""
        with open(output_file, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            
            # Header
            header = (truth_table.conditions + 
                     [truth_table.outcome, 'case_count', 'consistency', 'coverage', 'cases'])
            writer.writerow(header)
            
            # Data rows
            for row in truth_table.rows:
                data_row = []
                
                # Condition values
                for cond_id in truth_table.conditions:
                    data_row.append(row.configuration.get(cond_id, 0.0))
                
                # Outcome, metrics, cases
                data_row.extend([
                    row.outcome,
                    len(row.cases),
                    row.consistency or 0.0,
                    row.coverage or 0.0,
                    ';'.join(row.cases)
                ])
                writer.writerow(data_row)
    
    def run_minimization_phase(self, truth_tables: List[TruthTable] = None) -> List[str]:
        """Run complete Phase QCA-3: Boolean Minimization"""
        logger.info("=== Running Phase QCA-3: Boolean Minimization Integration ===")
        
        # Load truth tables
        self.load_truth_tables(truth_tables)
        
        # Create data exports
        export_files = self.create_qca_data_exports()
        
        # Generate analysis scripts for each truth table
        all_generated_files = []
        for truth_table in self.truth_tables:
            generated_files = self.run_external_qca_analysis(truth_table)
            all_generated_files.extend(generated_files.values())
        
        all_files = export_files + all_generated_files
        
        logger.info(f"Phase QCA-3 complete: {{len(all_files)}} files generated for external QCA analysis")
        return all_files